package dbu

import (
	"fmt"
	"reflect"
	"strings"
)

// BuildMongoUpdateMap constructs a map[string]any for use in MongoDB updates.
//
// It iterates over the fields of the input struct (or pointer to struct), extracts non-nil values,
// and builds a map where keys correspond to BSON field names.
// Unexported fields and fields with nil pointer values are skipped.
//
// Keys are determined by examining struct tags in priority:
// bson:"..." -> json:"..." -> form:"..." -> fallback to lower-casing the first letter of the field name.
// Tags with a value of "-" will cause the field to be skipped.
//
// Fields are skipped entirely if their derived key appears in the `skipFields` list.
// Note: This function processes all top-level fields (including embedded structs)
// individually. It does not explicitly handle or flatten embedded structs;
// embedded struct values (whether named or anonymous) will be included as nested
// Go struct values in the map, which MongoDB drivers typically serialize as
// nested BSON documents.
//
// Parameters:
//
//	x: The struct or pointer to struct to traverse. Must be a struct or pointer to a non-nil struct.
//	skipFields: A list of strings representing BSON field names (derived from tags or naming) to exclude from the result map. These apply to top-level keys generated by this function.
//
// Returns:
//
//	A map[string]any containing the extracted fields and their values, intended for MongoDB updates.
//	If the input is not a valid struct or pointer, an empty map is returned and a warning is printed.
//
// Example:
//
//		type Address struct {
//			Street string `bson:"street_addr"` // bson tag (highest within Address)
//			City   string `json:"city_name"`   // json tag (next within Address)
//			Zip    string `form:"zip_code"`    // form tag (fallback within Address)
//			Code   string // No tags, uses firstCharToLower -> "code" within Address
//		}
//		type User struct {
//			ID        string `bson:"_id"`    // bson tag (highest priority)
//			FirstName string `json:"first"` // json tag (next priority)
//			LastName  string `form:"last"`  // form tag (fallback priority)
//			Age       int    // No tags, uses firstCharToLower -> "age"
//			Status    *string `bson:"status"` // Pointer field with bson tag
//			Address   Address // Named embedded struct, treated as regular field
//			Profile   struct { // Anonymous embedded struct, treated as regular field
//				Public bool `bson:"is_public"` // bson tag within Profile
//			} // No tags on the anonymous field itself, uses firstCharToLower -> "profile"
//		}
//
//		status := "active"
//		user := User{
//			ID:        "abc",
//			FirstName: "Jane",
//			LastName:  "Doe",
//			Age:       30,
//	     Status:    &status, // Non-nil pointer
//			Address: Address{Street: "Main St", City: "Anytown", Zip: "12345", Code: "ABC"},
//	     Profile: struct { Public bool `bson:"is_public"`}{Public: true},
//		}
//
//		// Call BuildMongoUpdateMap(user, []string{"_id", "Age", "address", "profile"}) // skip top-level keys
//		// Expected map keys and values:
//		// {
//		//   "first": "Jane",        // json:"first" (no bson)
//		//   "last": "Doe",         // form:"last" (no bson, no json)
//		//   "status": "active",     // bson:"status" (has bson, pointer dereferenced)
//		//   "Address": Address{...}, // No tags on Address field, firstCharToLower("Address") -> "address". Value is the Struct.
//		//   // "profile": Profile{...}, // Skipped as "profile" is in skipFields.
//		// }
//		// Note: "_id" and "Age" are skipped. "address" is not skipped. "profile" is skipped.
//	 // The MongoDB driver would serialize the Address struct value {Street:"...", City:"...", Zip:"...", Code:"..."}
//	 // into a nested BSON document under the key "address".
//	 // Its internal fields (Street, City, Zip, Code) would get keys based on *their* tags/fallbacks
//	 // ("street_addr", "city_name", "zip_code", "code").
//	 // The Profile struct value {Public: true} would be nested under the key "profile",
//	 // and "Public" would get key "is_public" from its bson tag.
func BuildMongoUpdateMap(x any, skipFields []string) map[string]any {
	result := make(map[string]any)
	skipMap := make(map[string]struct{}, len(skipFields))
	for _, field := range skipFields {
		skipMap[field] = struct{}{}
	}

	val := reflect.ValueOf(x)
	typ := reflect.TypeOf(x)

	// Handle nil input pointer
	if typ.Kind() == reflect.Ptr && val.IsNil() {
		return result // Return empty map for nil pointer
	}

	// Dereference pointer if necessary
	if typ.Kind() == reflect.Ptr {
		val = val.Elem()
		typ = typ.Elem()
	}

	// Ensure it's a struct
	if typ.Kind() != reflect.Struct {
		// Log a warning instead of returning error, matching original function's behavior
		// Consider adding error return for robustness in real applications
		fmt.Printf("Warning: BuildMongoUpdateMap input is not a struct or pointer to struct, got %s\n", typ.Kind())
		return result
	}

	for i := range typ.NumField() { // Use < NumField()
		field := typ.Field(i)
		fieldVal := val.Field(i)

		// Skip unexported fields (Optimization/Robustness)
		if !fieldVal.CanInterface() {
			continue
		}

		// --- Key Naming Priority: bson -> json -> form -> firstCharToLower ---
		var name string
		bsonTag := field.Tag.Get("bson")
		jsonTag := field.Tag.Get("json")
		formTag := field.Tag.Get("form") // Get form tag value

		if bsonTag != "" && bsonTag != "-" {
			name = strings.Split(bsonTag, ",")[0] // Handle options like ",omitempty"
		} else if jsonTag != "" && jsonTag != "-" {
			name = strings.Split(jsonTag, ",")[0] // Handle options
		} else if formTag != "" && formTag != "-" { // Check form tag
			name = strings.Split(formTag, ",")[0] // Handle options
		} else {
			// Fallback to lower-casing the first character of the field name
			name = firstCharToLower(field.Name)
		}
		// --- End Key Naming ---

		// If the name is empty (e.g., tag was "-"), skip it
		if name == "" {
			continue
		}

		// Skip the field if its derived name is in the skipMap (Optimization)
		if _, shouldSkip := skipMap[name]; shouldSkip {
			continue
		}

		// Check if the field is a pointer and if it's a nil
		if fieldVal.Kind() == reflect.Ptr && fieldVal.IsNil() {
			continue
		}

		// Get the actual value (dereference pointer if necessary)
		var actualValue any
		if fieldVal.Kind() == reflect.Ptr {
			actualValue = fieldVal.Elem().Interface()
		} else {
			actualValue = fieldVal.Interface()
		}

		// Add the field/value to the map
		result[name] = actualValue
	}

	return result
}
